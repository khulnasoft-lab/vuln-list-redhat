{
  "affected_release": null,
  "package_state": [
    {
      "product_name": "Red Hat Enterprise Linux 6",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:6"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 7",
      "fix_state": "Out of support scope",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:7"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 8",
      "fix_state": "Not affected",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:8"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Fix deferred",
      "package_name": "kernel",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    },
    {
      "product_name": "Red Hat Enterprise Linux 9",
      "fix_state": "Fix deferred",
      "package_name": "kernel-rt",
      "cpe": "cpe:/o:redhat:enterprise_linux:9"
    }
  ],
  "threat_severity": "Moderate",
  "public_date": "2025-05-01T00:00:00Z",
  "bugzilla": {
    "description": "kernel: fscrypt: stop using keyrings subsystem for fscrypt_master_key",
    "id": "2363489",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2363489"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "5.5",
    "cvss3_scoring_vector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H",
    "status": "draft"
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2022-49899",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\nfscrypt: stop using keyrings subsystem for fscrypt_master_key\nThe approach of fs/crypto/ internally managing the fscrypt_master_key\nstructs as the payloads of \"struct key\" objects contained in a\n\"struct key\" keyring has outlived its usefulness.  The original idea was\nto simplify the code by reusing code from the keyrings subsystem.\nHowever, several issues have arisen that can't easily be resolved:\n- When a master key struct is destroyed, blk_crypto_evict_key() must be\ncalled on any per-mode keys embedded in it.  (This started being the\ncase when inline encryption support was added.)  Yet, the keyrings\nsubsystem can arbitrarily delay the destruction of keys, even past the\ntime the filesystem was unmounted.  Therefore, currently there is no\neasy way to call blk_crypto_evict_key() when a master key is\ndestroyed.  Currently, this is worked around by holding an extra\nreference to the filesystem's request_queue(s).  But it was overlooked\nthat the request_queue reference is *not* guaranteed to pin the\ncorresponding blk_crypto_profile too; for device-mapper devices that\nsupport inline crypto, it doesn't.  This can cause a use-after-free.\n- When the last inode that was using an incompletely-removed master key\nis evicted, the master key removal is completed by removing the key\nstruct from the keyring.  Currently this is done via key_invalidate().\nYet, key_invalidate() takes the key semaphore.  This can deadlock when\ncalled from the shrinker, since in fscrypt_ioctl_add_key(), memory is\nallocated with GFP_KERNEL under the same semaphore.\n- More generally, the fact that the keyrings subsystem can arbitrarily\ndelay the destruction of keys (via garbage collection delay, or via\nrandom processes getting temporary key references) is undesirable, as\nit means we can't strictly guarantee that all secrets are ever wiped.\n- Doing the master key lookups via the keyrings subsystem results in the\nkey_permission LSM hook being called.  fscrypt doesn't want this, as\nall access control for encrypted files is designed to happen via the\nfiles themselves, like any other files.  The workaround which SELinux\nusers are using is to change their SELinux policy to grant key search\naccess to all domains.  This works, but it is an odd extra step that\nshouldn't really have to be done.\nThe fix for all these issues is to change the implementation to what I\nshould have done originally: don't use the keyrings subsystem to keep\ntrack of the filesystem's fscrypt_master_key structs.  Instead, just\nstore them in a regular kernel data structure, and rework the reference\ncounting, locking, and lifetime accordingly.  Retain support for\nRCU-mode key lookups by using a hash table.  Replace fscrypt_sb_free()\nwith fscrypt_sb_delete(), which releases the keys synchronously and runs\na bit earlier during unmount, so that block devices are still available.\nA side effect of this patch is that neither the master keys themselves\nnor the filesystem keyrings will be listed in /proc/keys anymore.\n(\"Master key users\" and the master key users keyrings will still be\nlisted.)  However, this was mostly an implementation detail, and it was\nintended just for debugging purposes.  I don't know of anyone using it.\nThis patch does *not* change how \"master key users\" (-\u003emk_users) works;\nthat still uses the keyrings subsystem.  That is still needed for key\nquotas, and changing that isn't necessary to solve the issues listed\nabove.  If we decide to change that too, it would be a separate patch.\nI've marked this as fixing the original commit that added the fscrypt\nkeyring, but as noted above the most important issue that this patch\nfixes wasn't introduced until the addition of inline encryption support."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2022-49899\nhttps://nvd.nist.gov/vuln/detail/CVE-2022-49899\nhttps://lore.kernel.org/linux-cve-announce/2025050101-CVE-2022-49899-d331@gregkh/T"
  ]
}